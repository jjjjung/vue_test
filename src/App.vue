<template>
  <div id="app">
    <h1>PIG_Front</h1>

    <div class="tabW">
      <b-card no-body>
        <b-tabs pills card vertical>
          <b-tab title="Vue - 이벤트 한정자" active>
            <b-card-text>
              <p><span>a</span> <input type="text" v-model.number="number"> <span style="padding-left: 20px;">3 + a = </span> {{3+number}}</p>
              <p><span>b</span> <input type="text" v-model="normal"> <span style="padding-left: 20px;">3 + b = </span> {{3+normal}}</p>
              <b-alert variant="success" v-model="alert" dismissible>{{type3}} Alert</b-alert>
              <input type="text" @keyup.enter="showAlert()" v-model="type3">
            </b-card-text>
          </b-tab>
          <b-tab title="Tab 3">
            <b-card-text>Tab contents 3</b-card-text>
          </b-tab>
          <b-tab title="Tab 3">
            <b-card-text>Tab contents 3</b-card-text>
          </b-tab>
          <b-tab title="HTML,CSS">
            <b-card-text>

&lt;section&gt;과 &lt;div&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;article&gt; 엘리먼트의 차이점은 무엇인가요?
기본적인 스타일 속성은 같지만 내용이나 용도에 따라 구분하여 사용. 대체적으로 section은 내용의 구조를 만들 때, article은 페이지의 내용과 관련이 없는 독립적인 경우일 때 사용함.
Section : 내부 콘텐츠가 그룹화되어 페이지 개요에 항목으로 표시되어야 하는 요소
Header : 도입부에 해당하는 콘텐츠를 가지고 있는 부분
Footer: 사이트의 작성자나 저작권정보, 연락처 등의 정보를 담고 있는 부분
Article : html 문서에서 독립적인 하나의 기사로, 아티클 요소의 내용 자체만으로도 내용이 이해가 되어야 함
div : 별다른 의미 전달을 하지 않음
div외 나머지 요소들은 레이아웃만을 위한 시맨틱 태그로, 태그 스스로 브라우저와 개발자 모두에게 자신이 사용된 의미를 명확히 전달해 줌

블럭 레벨 엘리먼트와 인라인 엘리먼트의 차이는 무엇일까요?
블럭은 기본적으로 가로 폭을 모두 사용하고 width, height 사이즈 조절이나 padding 등의 여백 속성이 적용 가능하며 블럭 엘리먼트 안에 다른 블럭이나 인라인 엘리먼트 포함 가능.
인라인은 내용이 차지하는 영역만 사용하고 사이즈 조절이나 여백 속성은 적용할 수 없으며 안에 인라인 엘리먼트만 포함 가능.
블럭요소 : 줄바꿈이 일어나는 요소 (h1,p,div 등), 블럭, 인라인 요소 포함 가능
인라인 요소 : 줄바꿈이 없는 요소 (span, em, strong, a 등), 블럭요소 포함 불가능

시맨틱 웹(Semantic Web) 이 뭔가요?
검색엔진이나 AI 등의 컴퓨터가 자동으로 헤더나 푸터, 컨텐츠 영역의 구조를 파악 할 수 있는 웹. 시멘틱 태그인 header나 nav, footer 등을 사용하여 제작.
기계가 사람을 대신해서 웹 페이지의 정보를 이해하고, 우리에게 필요한 정보만 보여주거나 정보를 가공해서 우리가 필요로 하는 형태로 가공해주는 것으로
스스로 의미를 갖는 시멘틱 태그를 사용하여 작성된 웹 페이지

* CSS를 HTML에 적용하는 세 가지 방법과 장단점
* Inline Style
해당 태그 요소에만 스타일 적용. 우선순위가 가장 높음.
어떤 스타일을 적용 했는 지 알기는 쉽지만 2개 이상의 공통 스타일의 적용에는 비효율적.
방법 : 특정태그에만 스타일을 적용하고 싶을 때 사용
장점 : 1회용으로 하나의 태그에만 스타일을 적용 할 때 유용
단점 : 향후 스타일 변경 시 해당되는 모든 태그에 적용된 스타일을 일일이 변경해주어야 하여 유지보수가 어렵다
* &lt;style&gt;
해당 페이지에만 스타일 적용. 우선순위는 Inline Style 다음.
해당 페이지 내에서는 2개 이상의 공통 스타일 요소의 적용이 가능하지만 페이지가 많아지면 비효율적.
방법 : 페이지 상단에 적용하는 방식으로 한 문서에만 해당되는 스타일을 지정할때 사용
장점 : 스타일을 여러번 재사용 가능
단점 : 현재 페이지에서만 사용 가능하여 전체적인 사이트 스타일 변경 시 페이지 마다 변경 해주어야 함
* &lt;link rel="stylesheet" href="..."&gt;
외부 스타일 시트 파일 연결. 우선순위가 가장 낮음.
사이트의 모든 페이지에 동일한 스타일을 적용 가능하여 유지 보수가 편하지만 가독성이 낮고 로딩 속도와 같은 성능 면에서는 좋지 않음.
방법 : 별도의 파일(.css)을 만들어서 적용하는 방식으로 모든 페이지에 공통으로 적용해야할 때 사용
장점 : 사이트 전체의 스타일을 일관성있게 유지, 변경 시 일괄적으로 변경되어 유지보수 측면에서 편리함
단점 : 파일을 계속적으로 관리해주면서 HTML 문서를 만들어 나가야 하기에 불편,

* float 속성은 왜 좋지 않을까요?
강제로 요소를 띄워버리기 때문에 부모 요소가 자식 요소의 높이값을 인식 못함. clear를 사용해 float를 초기화 시키는 등의 추가 작업이 필요함.
플로트 박스를 포함하고 있는 부모 요소가 플로트 박스의 높이를 알 수 없기 때문에 레이아웃이 틀어지는 경우가 많고, 연성이 다소 떨어짐
플로트 박스 이후에는 플로트 박스를 해지하는 스타일을 지정해줘야 하며 부모 요소의 너비에 따라 자식 요소의 너비를 계산해줘야 하는 유지보수 측면의 불편 등
사용하기 위한 필요요소가 많고 유연성이 다소 떨어짐

Flexbox(Flexible box)와 CSS Grid의 차이와 장단점은 무엇일까요?
Flexbox는 1개의 행(row)의 레이아웃을 적용할 때 하위 요소들을 정렬하기에 간편하지만 행이 여러 개가 되면 첫 행의 속성을 다른 행이 그대로 가지기 때문에 다양한 레이아웃을 그리기 힘듦.
Grid는 여러 행의 레이아웃을 적용할 때 하위 요소 정렬에 효율적이고 간편하게 최적화 되어 있으나 브라우저 호환이 잘 안돼 크로스 브라우징이 어려움.
레이아웃을 다룰 때 한 번에 하나의 행이나 열만을 다루어 1차원이지만 그리드는 레이아웃 짜는데에 좀 더 유연하며 자유로워 2차원이라교 표현됨
Flexbox 장점 : 크기를 유연하게 조절할 수 있음, 마크업 순서와 별개로 동작하기 때문에 접근성에 제약을 받지 않음
Flexbox 단점 : 1차원 레이아웃이기 때문에 행 마다 새로운 플렉스 컨테이너를 선언하거나, 여러 속성을 복잡하게 계산해 활용해야 함, ie 브라우저의 지원이 제한적
Grid 장점 : 2차원 레이아웃이기 때문에 요소를 화면 크기에 따라 재정의가 가능하여 좀 더 세밀한 반응형 디자인이 가능
Grid 단점 : ie 브라우저의 지원이 제한적

* 브라우저가 브라우저의 윈도우 화면에 DOM을 생성하는 과정은 내부적으로 어떻게 진행되나요?
html 파싱 → 렌더 트리 구축 → 렌더 트리 배치 → 렌더 트리 그리기 순으로 진행.
렌더 트리는 문서(DOM)의 상단에서 하단으로 순차적으로 진행하며 렌더 요소의 CSS(CSSOM)를 찾아 불러 옴.
head태그나 display: none, hidden은 렌더 트리에 포함되지 않음(visibility: hidden은 공간을 차지한 채로 보이지 않을 뿐이라 렌더 트리에 포함).
변환 > 토큰화 > 렉싱 > DOM 생성
1. 변환 : HTML의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩에 따라 개별 문자로 변환
2. 토큰화 : 브라우저가 문자열을 W3C HTML5 표준에 지정된 고유 토큰으로 변환
3. 렉싱 : 방출된 토큰은 해당 속성 및 규칙을 정의하는 '객체'로 변환
4. DOM 생성 : HTML 마크업이 여러 태그간의 관계를 정의하기 때문에 생성된 객체는 트리 데이터 구조 내에 연결

크롬, 사파리, 익스플로러의 렌더링 엔진은 어떤 것입니까?
크롬 : 블링크
사파리 : 웹킷
익스플로러 : 트라이던트

* MVC는 무엇이고 왜 나타났나요?
Model(데이터와 로직), View(레이아웃과 화면), Controller(모델과 뷰를 컨트롤).
뷰가 모델로부터 데이터를 받고 컨트롤러가 입력을 받아 뷰와 모델을 컨트롤. 각 영역을 분리하여 개발 및 유지보수를 효율적으로 진행하기 위해 정함.
Model View Controller의 약자로 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴
어떤 특정한 역할들에 대해 역할분담을 할 때 가이드라인을 제시

* MVVM은 무엇이고 왜 나타났나요?
Model, View, ViewModel(View와 데이터바인딩<자동갱신> - 모델과 데이터를 주고 받음).
다른 패턴은 모델과 뷰의 높은 의존성 때문에 유지보수가 어려워 정함. 비교적 모델과 뷰의 상호 의존성이 낮아 테스트와 모듈화가 쉬움.
Model - View - ViewModel의 약자, 디자이너가 작업한 인터페이스 (실질적인 사용자들이 눈으로 볼 수 있는 페이지) 가 View 에 해당하고,
Database 와 통신하는 역할을 Model 이 담당하며 둘 사이에서,
View 와는 Binding 이나 Command 로 연결하고 Model 과는 데이터를 주고 받는 역할을 담당하는 녀석이 ViewModel
모든 비즈니스 논리와 GUI 환경설정이 명백하게 분리된 마틴 파울러의 프레젠테이션 모델 디자인 패턴을 특수화하기 위해

* MVVM을 지향하는 자바스크립트 프레임워크에는 무엇이 있나요?
Knockout.js, Angular, React, vue.js 등
            </b-card-text>
          </b-tab>
          <b-tab title="GIT">
            <b-card-text>
              <p><b>git clone</b>
              서버의 모든 파일을 로컬로 다운로드</p>
              <p><b>git add</b>
              로컬의 수정된 파일을 스테이지에 추가</p>
              <p><b>git commit</b>
              스테이지의 상태를 기록</p>
              <p><b>git push</b>
              commit한 내용을 서버로 업로드</p>
              <p><b>git pull</b>
              서버의 수정사항을 로컬로 다운로드</p>
              <p><b>git branch</b>
              서버 내에서의 작업공간 리스트 확인(동일한 프로젝트를 여러 버전으로 관리 가능)</p>
              <p><b>git stash</b>
              로컬의 수정 중인 파일을 임시 보관하고 가장 최근의 commit 상태로 만듦.</p>
              <p><b>버전 관리 시스템은 왜 필요한가요?</b>
              여러 명이 협업 시에 소스 간의 충돌을 방지하고 어떤 내용을 누가 수정했는 지 확인이 가능해 히스토리 관리가 쉬움. 오류가 났을 때 백업&복구 가능.</p>
              <p><b>git 외의 버전관리 시스템에는 무엇이 있나요? git은 그 시스템과 어떤 점이 다르며, 어떤 장점을 가지고 있나요?</b>
              SVN, mercurial 등이 있음.<br>
              중앙 서버에서 원하는 파일만 로컬에 받아 수정하는 SVN과는 달리, Git은 프로젝트 전체를 로컬에 다운 받은 뒤 수정하므로 중앙 서버에 문제가 생기더라도 어려움없이 복구나 작업이 가능.</p>
            </b-card-text>
          </b-tab>

        </b-tabs>
      </b-card>
    </div>



  </div>
</template>

<script>
export default {
  name: 'app',
  data () {
    return {
      number: 0,
      normal: '',
      type3: '',
      alert: false,
    }
  },
  methods: {
    showAlert() {
      console.log('aa');
      this.alert = !this.alert;
    }

  }
}
</script>

<style>
#app {
  padding: 20px;
}
.tabW {
  margin-top: 40px;
}
.tabW b {
  display: block;
}
</style>
